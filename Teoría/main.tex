\documentclass{article}

\input{packages.tex}

\title{}
\author{}
\date{}

\begin{document}
	
%	\maketitle
%	
%	\begin{abstract}\end{abstract}
%	
%	\tableofcontents
	
	\section{Versión 1}
	La primera versión consiste en realizar una búsqueda en anchura estándar sobre el árbol de soluciones. Es decir, se recorre cada posible solución, pero recorriendo todas las posibilidades de longitud $n$ antes de pasar a las soluciones de longitud $n+1$. Así nos aseguramos de que pasamos por la solución óptima antes que cualquier otra.
	
	El código del que partimos es el siguiente:
	
	\lstinputlisting{v1.cpp}
	
	\subsection{Restricciones}
	\begin{enumerate}
		\item Está en C++.
		\item A partir de 1000 tarda demasiado.
		\item No se tienen en cuenta operaciones encestadas: (17-2)/(2+3)
		\item Tiene más paréntesis de la cuenta.
	\end{enumerate}

	\subsection{A hacer}
	\begin{enumerate}
		\item Ver si ayuda optimizar factorizando.
		\item Ver cuál sería la estructura óptima (x*y+-z).
	\end{enumerate}

	$\ell(n)=\log_{97}(n)\leq f(n)\leq 4 \log_{97}(n)+3=s(n)$
	
	$\liminf\limits_{n\to\infty}\dfrac{f(n)}{\log_{97}(n)}=1$
	
	Si $n<10^{10}$, entonces $f(n)<24$
	
	$f(n)$ lo puedo hacer en al menos $u(n)$ movimientos.
	
	Si $\ell(u)+1 > s(u\oplus v)$ entonces no vale la pena seguir por ahí.
	
\end{document}
